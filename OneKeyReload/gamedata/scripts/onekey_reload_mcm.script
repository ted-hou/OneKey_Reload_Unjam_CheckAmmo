local mcm_key_reload = DIK_keys.DIK_R
local mcm_modifier_unjam = 1

function on_game_start()
    RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
    RegisterScriptCallback("on_option_change", on_option_change)
    RegisterScriptCallback("on_before_key_press", on_before_key_press)
    RegisterScriptCallback("on_key_hold", on_key_hold)
end

function on_mcm_load()
    op = {
        id = "reload",
        sh = true,
        gr = {
            { id = "slide_onekey_reload", type = "slide", link = "ui_options_slider_player", text = "ui_mcm_title_onekey_reload", size = { 512, 50 }, spacing = 20 },            
            { id = "desc_onekey_reload", type = "desc", text = "ui_mcm_onekey_key_reload_desc" },            
            { id = "key_reload", type = "key_bind", val = 2, def = DIK_keys.DIK_R, hint = "onekey_key_reload" },
            { id = "modifier_unjam", type = "radio_h", val = 2, def = 1, hint = "onekey_unjam_modifier", content = { {1,"mcm_kb_mod_shift"} , {2,"mcm_kb_mod_ctrl"}, {3,"mcm_kb_mod_alt"} } },
        }
    }
    return op, "onekey"
end

function actor_on_first_update()
    on_option_change()
end

function on_option_change()
    if ui_mcm then
        mcm_key_reload = ui_mcm.get("onekey/reload/keybind_reload")
        mcm_modifier_unjam = ui_mcm.get("onekey/reload/modifier_unjam")
    end
end

function on_before_key_press(key, bind, dis, flags)
    if bind == key_bindings.kWPN_RELOAD or key == mcm_key_reload then
        -- passthrough if no weapon active
        local weapon = db.actor:active_item()
        if (weapon == nil or (not IsWeapon(weapon)) or IsItem("fake_ammo_wpn", nil, weapon)) then
            flags.ret_value = true
            return
        end

        if not main_hud_shown() then
            printf("Main hud hidden, emulating ammo select key press.")
            level.press_action(bind_to_dik(key_bindings.kWPN_NEXT))
            level.release_action(bind_to_dik(key_bindings.kWPN_NEXT))
            flags.ret_value = false
            return
        end

        -- Unjam or reload depending on modifier
        if ui_mcm.get_mod_key(mcm_modifier_unjam) then
            ui_mcm.simple_press("magazines_onekey_press_unjam", key, try_unjam_weapon)
        else
            ui_mcm.simple_press("magazines_onekey_press_reload", key, try_reload_weapon)
        end

        -- Double-tap to ammo-select
        if ui_mcm.double_tap("magazines_onekey_doubletap_changeammo", key) then
            -- level.press_action(bind_to_dik(key_bindings.kWPN_NEXT))
            -- level.release_action(bind_to_dik(key_bindings.kWPN_NEXT))
            -- item_weapon.start_ammo_wheel()
            printf("[OKR] calling switch_next_ammo()")
            local success = try_switch_next_ammo()
            if not success then
                printf("[OKR] could not switch ammo, reloading instead")
                try_reload_weapon()
            end
        end

        -- Suppress the keypress since it has been handled.
        flags.ret_value = false
    end
end

function on_key_hold(key)
    local bind = dik_to_bind(key)
    -- Hold reload key to ammo check
    if ((bind == key_bindings.kWPN_RELOAD or key == mcm_key_reload) and ui_mcm.key_hold("magazines_onekey_hold", key)) then
        ammo_check_mcm.check_Ammo()
    end
end


function try_unjam_weapon()
    local weapon = db.actor:item_in_slot(db.actor:active_slot())
    if weapon then
        arti_jamming.unjam(weapon)
    end
end

function try_reload_weapon()
    local weapon = db.actor:item_in_slot(db.actor:active_slot())
    -- Don't reload unless weapon is in idle state
    local state = weapon and weapon:get_state()
    if not weapon or weapon:weapon_in_grenade_mode() or state ~= 0 then
        return
    end

    if magazine_binder.is_supported_weapon(weapon) then
        magazines.actor_on_weapon_reload(db.actor, weapon)
    else
        db.actor:reload_weapon()
    end
    CreateTimeEvent("magazines_onekey_reload", "ammo_check_on_reload", 0.1, ammo_check_mcm.check_ammo_after_reload)
end


-- Cache the available ammo types for each weapon
local cached_ammo_types = {}

function get_ammo_data(weapon)
    local id = weapon:id()
    local section = weapon:section()
    local ammo_type = weapon:get_ammo_type()

    -- Find all magazines (or loose ammo for unsupported weapons) in player inventory
    local inventory_ammo = {}
    if magazines and magazine_binder.is_supported_weapon(weapon) then
        inventory_ammo = magazines.count_magazines(weapon)
    else
        local function itr(temp, itm)
            local section = itm:section()
            if IsItem("ammo",section) or IsItem("grenade_ammo",section) then
                inventory_ammo[section] = (inventory_ammo[section] or 0) + itm:ammo_get_count()
            end
        end
        db.actor:iterate_inventory(itr, nil)
    end

    -- Fetch usable ammo types from config
    local ammo_types
    if (not cached_ammo_types[id]) then
        ammo_types = utils_item.get_ammo(section, id)
        cached_ammo_types[id] = ammo_types
    else
        ammo_types = cached_ammo_types[id]
    end

    -- Check if ammo is in inventory (ignoring old ammo)
    local has_ammo_types = {}
    for i = 1, #ammo_types do
        local section = ammo_types[i]
        local is_bad_ammo_type = section and string.find(section, "verybad") and true or false
        has_ammo_types[i] = (not is_bad_ammo_type) and (inventory_ammo[section] and (inventory_ammo[section] > 0)) and true or false
    end

    return ammo_types, has_ammo_types
end

-- Return top round type (zero-based index) in the magazine (ignoring the chambered round)
function get_current_ammo_type(weapon, ammo_types)
    if magazines and magazine_binder.is_supported_weapon(weapon) then
        mag_data = magazine_binder.get_mag_loaded(weapon:id())
        -- No mag or empty mag: use the round in chamber (or the last one fired if none chambered)
        if not mag_data or weapon:get_ammo_in_magazine() <= 1 then
            current_ammo_type = weapon:get_ammo_type()
        else
            -- one-chambered, peek below to check top round in mag
            if magazines.retain_round(weapon) then
                top_round = mag_data.loaded[#mag_data.loaded - 1]
            -- open bolt: check top round in mag
            else
                top_round = stack.peek(mag_data.loaded)
            end
            current_ammo_type = weapon:get_ammo_type() -- fallback if the loop below did not find anything
            for i, sec in ipairs(ammo_types) do
                if top_round == sec then
                    current_ammo_type = i - 1 -- convert to zero-based
                    break
                end
            end
        end
    else
        current_ammo_type = weapon:get_ammo_type()
    end
    return current_ammo_type
end

function try_switch_next_ammo()
    local weapon = db.actor:active_item()
    if weapon and IsWeapon(weapon) and (not IsItem("fake_ammo_wpn", nil, weapon)) then
        local next_ammo_type
        local ammo_types
        local has_ammo_types
        ammo_types, has_ammo_types = get_ammo_data(weapon)
        local current_ammo_type = get_current_ammo_type(weapon, ammo_types) -- a number
        printf("[OKR] found current_ammo_type = %s", current_ammo_type)


        -- Find the next available ammo type
        for i = current_ammo_type + 2, #ammo_types do -- +2 because we need next type (+1 is the current type in ammo table)
            if has_ammo_types[i] then
                next_ammo_type = i
                break
            end
        end

        -- Loop around and find the next available ammo type
        if not next_ammo_type then
            for i = 1, current_ammo_type do
                if has_ammo_types[i] then
                    next_ammo_type = i
                    break
                end
            end
        end

        if next_ammo_type then
            printf("[OKR] found next_ammo_type = %s", next_ammo_type)
            if magazines and magazine_binder.is_supported_weapon(weapon) then
                local ammo_map = utils_item.get_ammo(nil, weapon:id())
                local magazine = magazines.find_magazine(weapon, ammo_map[next_ammo_type])
                if magazines.get_mag_data(weapon:id()) then
                    magazines.print_dbg("Weapon already has magazine, ejecting first")
                    magazines.eject_magazine(weapon)
                end
                local pre_table = magazines.count_ammo(weapon)
                weapon:switch_state(7)
                disable_info("sleep_active")
                local chambered_round = nil
                if magazines_mcm.get_config("retain_round") and weapon:get_ammo_in_magazine() > 0 then
                    chambered_round = magazines.get_sec_chambered(weapon)
                    magazines.print_dbg("Mag swap - chambered round is %s", chambered_round)
                end
                magazines.action_start_reload()
                CreateTimeEvent("mag_redux", "delay_weapon"..weapon:id(), 0.1, magazines.delay_load_weapon, weapon, magazine, pre_table, first_round)
            else
                weapon:unload_magazine(true)
                weapon:set_ammo_type(next_ammo_type - 1) -- ammotype is zero-indexed
                db.actor:reload_weapon()
            end
            CreateTimeEvent("magazines_onekey_reload", "ammo_check_on_reload", 0.1, ammo_check_mcm.check_ammo_after_reload)
            return true
        end

        printf("[OKR] could not switch to next ammo type")
        return false
    end
end